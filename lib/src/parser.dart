import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/painting.dart';

import 'color.dart';
import 'constants.dart';
import 'flutter_renderer.dart';
import 'markup/markup.dart';
import 'span.dart';
import 'tokenization/token.dart';
import 'tokenization/tokenizer.dart';

/// Generate an [InlineSpan] tree by using the [Token] generated by [HypertextTokenizer]
class HypertextParser {
  HypertextParser(
    String text, {
    required Map<String, HyperMarkup> markups,
    bool? lowercaseAttrName,
    bool? lowercaseElementName,
    this.eventHandler,
    this.colorMapper,
    bool? ignoreErrorMarkup,
  })  : _markups = markups,
        _ignoreErrorMarkup = ignoreErrorMarkup ?? false,
        _tokenizer = HypertextTokenizer(
          text,
          lowercaseAttrName: lowercaseAttrName ?? true,
          lowercaseElementName: lowercaseElementName ?? true,
        );

  final HypertextEventHandler? eventHandler;

  final Map<String, HyperMarkup> _markups;

  final HypertextTokenizer _tokenizer;

  final _elementStack = ListQueue();

  final bool _ignoreErrorMarkup;
  final ColorMapper? colorMapper;

  /// 解析内容
  ///
  /// 对所有词法单元做深度优先遍历，构建一颗[InlineSpan]树
  List<HypertextSpan>? parse() {
    while (_tokenizer.moveNext()) {
      var token = _tokenizer.current;
      if (token is EndTagToken) {
        _popElement(token);
      } else {
        _pushElement(token);
      }
    }

    return _elementStack.map(_clearUp).toList();
  }

  void _pushElement(Token token) {
    if (token is StartTagToken) {
      if (token.selfClosing) {
        _elementStack.addLast(_markup(token));
      } else {
        _elementStack.addLast(token);
      }
    } else if (token is CharactersToken) {
      _elementStack.addLast(HypertextTextSpan(text: token.data));
    } else if (token is SpaceCharactersToken) {
      _elementStack.addLast(HypertextTextSpan(text: token.data));
    }
  }

  /// 向上查找起始元素，将内容合并到[InlineSpan]
  void _popElement(EndTagToken end) {
    int startTagIndex = -1;

    // 向上查找对应的起始元素
    for (var i = _elementStack.length - 1; i >= 0; i--) {
      var ele = _elementStack.elementAt(i);
      if (ele is StartTagToken && !ele.selfClosing && ele.name == end.name) {
        startTagIndex = i;
        break;
      }
    }

    // 未找到对应的起始元素，该`</tag>`将被遗忘
    if (startTagIndex == -1) return;

    // 从下往上合并到[InlineSpan]
    List<HypertextSpan>? children;
    for (var i = _elementStack.length - 1; i >= startTagIndex; i--) {
      var ele = _elementStack.removeLast();

      if (ele is CharactersToken) {
        children ??= [];
        children.add(HypertextTextSpan(text: ele.data));
      } else if (ele is SpaceCharactersToken) {
        children ??= [];
        children.add(HypertextTextSpan(text: ele.data));
      } else if (ele is HypertextSpan) {
        children ??= [];
        children.add(ele);
      } else if (ele is StartTagToken) {
        if (i != startTagIndex) {
          children ??= [];
          children.add(HypertextTextSpan(text: ele.rawTag));
          continue;
        }
        _elementStack.addLast(_markup(ele, children?.reversed.toList()));
      } else {
        debugPrint('Unhandled Token[$ele]');
      }
    }
  }

  HypertextSpan _markup(StartTagToken token, [List<HypertextSpan>? children]) {
    final m = _markups[token.name];
    return m?.markup(children, token, eventHandler, colorMapper) ??
        HypertextTextSpan(children: children);
  }

  HypertextSpan _clearUp(dynamic element) {
    if (element is HypertextSpan) return element;
    if (_ignoreErrorMarkup) return kEmptyHypertextSpan;

    // 这是一个错误的标签，将其文本化
    if (element is StartTagToken) {
      if (kDebugLogging) {
        debugPrint('Unable to handle Token[$element]');
      }
      return HypertextTextSpan(text: element.rawTag);
    }
    throw Exception('Illegal tag $element');
  }
}
