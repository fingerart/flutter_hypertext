import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/painting.dart';

import 'color.dart';
import 'constants.dart';
import 'flutter_renderer.dart';
import 'markup/markup.dart';
import 'span.dart';
import 'tokenization/token.dart';
import 'tokenization/tokenizer.dart';
import 'utils.dart';

/// Generate an [InlineSpan] tree by using the [Token] generated by [HypertextTokenizer]
class HypertextParser {
  factory HypertextParser(
    String text, {
    required List<HyperMarkup> markups,
    bool? lowercaseAttrName,
    bool? lowercaseElementName,
    HypertextEventHandler? eventHandler,
    ColorMapper? colorMapper,
    bool? ignoreErrorMarkup,
  }) {
    final mm = <String, HyperMarkup>{};
    Set<PatternMarkup>? patterns;
    for (var markup in markups) {
      for (var tag in markup.tags) {
        mm[tag] = markup;
      }
      if (markup is PatternMarkup) (patterns ??= <PatternMarkup>{}).add(markup);
    }
    return HypertextParser._(
      text,
      markups: mm,
      patterns: patterns,
      lowercaseAttrName: lowercaseAttrName,
      lowercaseElementName: lowercaseElementName,
      eventHandler: eventHandler,
      colorMapper: colorMapper,
      ignoreErrorMarkup: ignoreErrorMarkup,
    );
  }

  HypertextParser._(
    String text, {
    required Map<String, HyperMarkup> markups,
    Set<PatternMarkup>? patterns,
    bool? lowercaseAttrName,
    bool? lowercaseElementName,
    this.eventHandler,
    this.colorMapper,
    bool? ignoreErrorMarkup,
  })  : _markups = markups,
        _patternMarkups = patterns,
        _ignoreErrorMarkup = ignoreErrorMarkup ?? false,
        _tokenizer = HypertextTokenizer(
          text,
          lowercaseAttrName: lowercaseAttrName ?? true,
          lowercaseElementName: lowercaseElementName ?? true,
        );

  final HypertextEventHandler? eventHandler;

  final Map<String, HyperMarkup> _markups;

  final Set<PatternMarkup>? _patternMarkups;

  final HypertextTokenizer _tokenizer;

  final _elementStack = ListQueue();

  final bool _ignoreErrorMarkup;
  final ColorMapper? colorMapper;

  /// 解析内容
  ///
  /// 对所有词法单元做深度优先遍历，构建一颗[InlineSpan]树
  List<HypertextSpan>? parse() {
    while (_tokenizer.moveNext()) {
      _consumeToken(_tokenizer.current);
    }

    return _elementStack.map(_clearUp).toList();
  }

  void _consumeToken(Token token, {bool fromPattern = false}) {
    if (token is EndTagToken) {
      _popElement(token);
    } else {
      _pushElement(token, fromPattern: fromPattern);
    }
  }

  void _pushElement(Token token, {bool fromPattern = false}) {
    if (token is StartTagToken) {
      if (token.selfClosing) {
        _elementStack.addLast(_markup(token));
      } else {
        _elementStack.addLast(token);
      }
    } else if (token is CharactersToken) {
      if (_patternMarkups.isEmpty || fromPattern) {
        _elementStack.addLast(HypertextTextSpan(text: token.data));
      } else {
        PatternParser(token.data, this, patterns: _patternMarkups!).parse();
      }
    } else if (token is SpaceCharactersToken) {
      _elementStack.addLast(HypertextTextSpan(text: token.data));
    }
  }

  /// 向上查找起始元素，将内容合并到[InlineSpan]
  void _popElement(EndTagToken end) {
    int startTagIndex = -1;

    // 向上查找对应的起始元素
    for (var i = _elementStack.length - 1; i >= 0; i--) {
      var ele = _elementStack.elementAt(i);
      if (ele is StartTagToken && !ele.selfClosing && ele.name == end.name) {
        startTagIndex = i;
        break;
      }
    }

    // 未找到对应的起始元素，该`</tag>`将被遗忘
    if (startTagIndex == -1) return;

    // 从下往上合并到[InlineSpan]
    List<HypertextSpan>? children;
    for (var i = _elementStack.length - 1; i >= startTagIndex; i--) {
      var ele = _elementStack.removeLast();

      if (ele is CharactersToken) {
        children ??= [];
        children.add(HypertextTextSpan(text: ele.data));
      } else if (ele is SpaceCharactersToken) {
        children ??= [];
        children.add(HypertextTextSpan(text: ele.data));
      } else if (ele is HypertextSpan) {
        children ??= [];
        children.add(ele);
      } else if (ele is StartTagToken) {
        if (i != startTagIndex) {
          children ??= [];
          children.add(HypertextTextSpan(text: ele.rawTag));
          continue;
        }
        _elementStack.addLast(_markup(ele, children?.reversed.toList()));
      } else {
        debugPrint('Unhandled Token[$ele]');
      }
    }
  }

  HypertextSpan _markup(StartTagToken token, [List<HypertextSpan>? children]) {
    final m = _markups[token.name];
    return m?.markup(children, token, eventHandler, colorMapper) ??
        HypertextTextSpan(children: children);
  }

  HypertextSpan _clearUp(dynamic element) {
    if (element is HypertextSpan) return element;
    if (_ignoreErrorMarkup) return kEmptyHypertextSpan;

    // 这是一个错误的标签，将其文本化
    if (element is StartTagToken) {
      if (kDebugLogging) {
        debugPrint('Unable to handle Token[$element]');
      }
      return HypertextTextSpan(text: element.rawTag);
    }
    throw Exception('Illegal tag $element');
  }
}

class PatternParser {
  PatternParser(this.source, this._tree, {required this.patterns});

  final String source;
  final HypertextParser _tree;

  final Set<PatternMarkup> patterns;

  int pos = 0;
  int start = 0;

  int charAt(int index) => source.codeUnitAt(index);

  void writeText() {
    if (pos == start) {
      return;
    }
    final text = source.substring(start, pos);
    _tree._consumeToken(CharactersToken(text), fromPattern: true);
    start = pos;
  }

  /// Add [token] to the current tree.
  void addToken(Token token) {
    _tree._consumeToken(token, fromPattern: true);
  }

  bool get isDone => pos == source.length;

  void advanceBy(int length) {
    pos += length;
  }

  void consume(int length) {
    pos += length;
    start = pos;
  }

  void parse() {
    while (!isDone) {
      if (patterns.any((element) => element.tryMatch(this))) continue;
      advanceBy(1);
    }
    writeText();
  }
}
